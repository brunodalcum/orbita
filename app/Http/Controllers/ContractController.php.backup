<?php

namespace App\Http\Controllers;

use App\Models\Contract;
use App\Models\ContractDocument;
use App\Models\ContractTemplate;
use App\Models\User;
use App\Models\Licenciado;
use App\Models\Operacao;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Str;
use Barryvdh\DomPDF\Facade\Pdf;
use Carbon\Carbon;

class ContractController extends Controller
{
    public function index(Request $request)
    {
        $query = Contract::with(['licenciado', 'documents', 'approvedBy', 'contractSentBy'])
            ->active();

        // Filtros
        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('search')) {
            $search = $request->search;
            $query->whereHas('licenciado', function($q) use ($search) {
                $q->where('razao_social', 'like', "%{$search}%")
                  ->orWhere('nome_fantasia', 'like', "%{$search}%")
                  ->orWhere('email', 'like', "%{$search}%")
                  ->orWhere('cnpj_cpf', 'like', "%{$search}%");
            });
        }

        $contracts = $query->orderBy('created_at', 'desc')->paginate(15);

        $statusStats = [
            'criado' => Contract::active()->byStatus('criado')->count(),
            'contrato_enviado' => Contract::active()->byStatus('contrato_enviado')->count(),
            'aguardando_assinatura' => Contract::active()->byStatus('aguardando_assinatura')->count(),
            'contrato_assinado' => Contract::active()->byStatus('contrato_assinado')->count(),
            'licenciado_aprovado' => Contract::active()->byStatus('licenciado_aprovado')->count(),
            'cancelado' => Contract::active()->byStatus('cancelado')->count(),
        ];

        return view('dashboard.contracts.index', compact('contracts', 'statusStats'));
    }

    public function show(Contract $contract)
    {
        $contract->load(['licenciado', 'documents.reviewedBy', 'auditLogs.user', 'approvedBy', 'contractSentBy']);
        
        return view('dashboard.contracts.show', compact('contract'));
    }

    public function create()
    {
        // Buscar licenciados da tabela licenciados que n√£o t√™m contrato
        $licenciados = Licenciado::whereDoesntHave('contract')
            ->whereIn('status', ['aprovado', 'ativo']) // Licenciados aprovados ou ativos
            ->orderBy('razao_social')
            ->get();

        return view('dashboard.contracts.create', compact('licenciados'));
    }

    public function store(Request $request)
    {
        $request->validate([
            'licenciado_id' => 'required|exists:licenciados,id',
            'observacoes_admin' => 'nullable|string|max:1000'
        ]);

        // Verificar se o licenciado j√° tem contrato
        $existingContract = Contract::where('licenciado_table_id', $request->licenciado_id)
            ->active()
            ->first();

        if ($existingContract) {
            return redirect()->back()->withErrors(['licenciado_id' => 'Este licenciado j√° possui um contrato ativo.']);
        }

        $contract = Contract::create([
            'licenciado_table_id' => $request->licenciado_id,
            'status' => 'criado',
            'observacoes_admin' => $request->observacoes_admin
        ]);

        // Log da cria√ß√£o
        $contract->logAction(
            'contrato_criado',
            'Contrato criado para o licenciado',
            auth()->id(),
            ['licenciado_id' => $request->licenciado_id]
        );

        return redirect()->route('contracts.show', $contract)
            ->with('success', 'Contrato criado com sucesso!');
    }

    public function reviewDocuments(Request $request, Contract $contract)
    {
        $request->validate([
            'document_reviews' => 'required|array',
            'document_reviews.*.status' => 'required|in:aprovado,rejeitado',
            'document_reviews.*.notes' => 'nullable|string|max:500'
        ]);

        $contract->update(['status' => 'documentos_em_analise']);

        foreach ($request->document_reviews as $docId => $review) {
            $document = $contract->documents()->find($docId);
            if ($document) {
                if ($review['status'] === 'aprovado') {
                    $document->approve($review['notes'] ?? null);
                } else {
                    $document->reject($review['notes'] ?? null);
                }
            }
        }

        // Verificar se todos os documentos foram aprovados
        if ($contract->hasAllDocumentsApproved()) {
            $contract->update([
                'status' => 'documentos_aprovados',
                'documents_approved_at' => now(),
                'approved_by' => auth()->id()
            ]);

            $contract->logAction(
                'documentos_aprovados',
                'Todos os documentos foram aprovados',
                auth()->id()
            );
        }

        return redirect()->route('dashboard.contracts.show', $contract)
            ->with('success', 'Documentos analisados com sucesso!');
    }

    public function downloadDocument(ContractDocument $document)
    {
        if (!$document->fileExists()) {
            return redirect()->back()->withErrors(['error' => 'Arquivo n√£o encontrado.']);
        }

        return Storage::disk('private')->download($document->file_path, $document->original_name);
    }

    public function generateContract(Contract $contract)
    {
        if (!$contract->canSendContract()) {
            return redirect()->back()->withErrors(['error' => 'Contrato n√£o pode ser enviado neste momento.']);
        }

        try {
            // Verificar campos obrigat√≥rios
            $missingFields = $this->validateRequiredFields($contract);
            if (!empty($missingFields)) {
                return redirect()->back()->withErrors([
                    'error' => 'Campos obrigat√≥rios n√£o preenchidos: ' . implode(', ', $missingFields)
                ]);
            }

            // Obter template padr√£o
            $template = ContractTemplate::getDefault();
            if (!$template) {
                return redirect()->back()->withErrors(['error' => 'Template de contrato n√£o encontrado.']);
            }

            // Preparar dados para o contrato
            $contractData = $this->prepareContractData($contract);

            // Gerar hash √∫nico
            $contractHash = hash('sha256', $contract->id . time() . Str::random(32));

            // Gerar PDF
            $pdf = $this->generatePDF($template, $contractData);
            
            // Salvar PDF
            $fileName = "contrato_{$contract->id}_{$contractHash}.pdf";
            $filePath = "contracts/{$contract->id}/{$fileName}";
            
            Storage::disk('private')->put($filePath, $pdf->output());

            // Atualizar contrato
            $contract->update([
                'template_id' => $template->id,
                'contract_pdf_path' => $filePath,
                'contract_hash' => $contractHash,
                'contract_data' => $contractData,
                'generated_at' => now(),
                'status' => 'contrato_enviado',
                'contract_sent_at' => now(),
                'contract_sent_by' => auth()->id()
            ]);

            // Gerar token de assinatura
            $signatureToken = $contract->generateSignatureToken();

            // Log da a√ß√£o
            $contract->logAction(
                'contrato_gerado',
                'Contrato gerado e enviado automaticamente',
                auth()->id(),
                [
                    'file_path' => $filePath,
                    'contract_hash' => $contractHash,
                    'signature_token' => $signatureToken,
                    'template_id' => $template->id
                ]
            );

            // Enviar por email (implementar depois)
            $this->sendContractEmail($contract, $signatureToken);

            return redirect()->route('contracts.show', $contract)
                ->with('success', 'Contrato gerado e enviado com sucesso!');

        } catch (\Exception $e) {
            // Log do erro
            $contract->logAction(
                'erro_geracao',
                'Erro ao gerar contrato: ' . $e->getMessage(),
                auth()->id(),
                ['error' => $e->getMessage(), 'trace' => $e->getTraceAsString()]
            );

            return redirect()->back()->withErrors(['error' => 'Erro ao gerar contrato: ' . $e->getMessage()]);
        }
    }

    public function previewContract(Contract $contract)
    {
        if (!$contract->canSendContract()) {
            return response()->json(['error' => 'Contrato n√£o pode ser visualizado neste momento.'], 400);
        }

        try {
            // Verificar campos obrigat√≥rios
            $missingFields = $this->validateRequiredFields($contract);
            if (!empty($missingFields)) {
                return response()->json([
                    'error' => 'Campos obrigat√≥rios n√£o preenchidos',
                    'missing_fields' => $missingFields
                ], 400);
            }

            // Obter template padr√£o
            $template = ContractTemplate::getDefault();
            if (!$template) {
                return response()->json(['error' => 'Template de contrato n√£o encontrado.'], 404);
            }

            // Preparar dados para o contrato
            $contractData = $this->prepareContractData($contract);

            // Gerar PDF de preview
            $pdf = $this->generatePDF($template, $contractData);

            return response($pdf->output(), 200)
                ->header('Content-Type', 'application/pdf')
                ->header('Content-Disposition', 'inline; filename="preview_contrato_' . $contract->id . '.pdf"');

        } catch (\Exception $e) {
            return response()->json(['error' => 'Erro ao gerar preview: ' . $e->getMessage()], 500);
        }
    }

    private function validateRequiredFields(Contract $contract): array
    {
        $template = ContractTemplate::getDefault();
        if (!$template) {
            return ['Template n√£o encontrado'];
        }

        $contractData = $this->prepareContractData($contract);
        return $template->validateRequiredFields($contractData);
    }

    private function prepareContractData(Contract $contract): array
    {
        $licenciado = $contract->licenciado;
        $operacao = Operacao::first(); // Pegar opera√ß√£o padr√£o ou configurar

        return [
            'contratante' => [
                'nome' => $licenciado->razao_social ?? '',
                'cnpj' => $this->formatCNPJ($licenciado->cnpj_cpf ?? ''),
                'cnpj_formatted' => $this->formatCNPJ($licenciado->cnpj_cpf ?? ''),
                'ie' => '', // Campo n√£o existe na tabela licenciados
                'endereco' => $licenciado->endereco ?? '',
                'cidade' => $licenciado->cidade ?? '',
                'uf' => $licenciado->estado ?? '',
                'cep' => $this->formatCEP($licenciado->cep ?? ''),
                'cep_formatted' => $this->formatCEP($licenciado->cep ?? '')
            ],
            'representante' => [
                'nome' => $licenciado->nome_fantasia ?? $licenciado->razao_social ?? '',
                'cpf' => '', // Campo n√£o existe na tabela licenciados
                'cpf_formatted' => '',
                'email' => $licenciado->email ?? '',
                'telefone' => $this->formatPhone($licenciado->telefone ?? ''),
                'telefone_formatted' => $this->formatPhone($licenciado->telefone ?? '')
            ],
            'contratada' => [
                'nome' => $operacao->company_name ?? 'DSPAY TECNOLOGIA LTDA',
                'cnpj' => $this->formatCNPJ($operacao->cnpj ?? '00.000.000/0001-00'),
                'cnpj_formatted' => $this->formatCNPJ($operacao->cnpj ?? '00.000.000/0001-00'),
                'endereco' => $operacao->address ?? 'Endere√ßo da empresa',
                'cidade' => $operacao->city ?? 'S√£o Paulo',
                'uf' => $operacao->state ?? 'SP',
                'cep' => $this->formatCEP($operacao->zipcode ?? '00000-000'),
                'cep_formatted' => $this->formatCEP($operacao->zipcode ?? '00000-000')
            ],
            'contrato' => [
                'data' => Carbon::now()->locale('pt_BR')->translatedFormat('j \d\e F \d\e Y'),
                'data_formatted' => Carbon::now()->locale('pt_BR')->translatedFormat('j \d\e F \d\e Y'),
                'id' => str_pad($contract->id, 6, '0', STR_PAD_LEFT),
                'id_formatted' => 'CONT-' . str_pad($contract->id, 6, '0', STR_PAD_LEFT),
                'hash' => $contract->contract_hash ?? 'PREVIEW'
            ],
            'licensee' => $licenciado,
            'operation' => $operacao,
            'contract' => $contract
        ];
    }

    private function generatePDF(ContractTemplate $template, array $data)
    {
        // Renderizar template
        $html = view('contracts.templates.default', $data)->render();
        
        // Substituir placeholders conforme especifica√ß√£o do usu√°rio
        $licenciado = $data['licensee'] ?? null;
        if ($licenciado) {
            $placeholders = [
                '{{NOME}}' => $licenciado->razao_social ?? 'Nome n√£o informado',
                '{{CNPJ}}' => $this->formatCNPJ($licenciado->cnpj_cpf ?? ''),
                '{{ENDERECO}}' => $this->buildFullAddress($licenciado),
                '{{CONCEP}}' => $licenciado->concep ?? 'CONCEP n√£o informado'
            ];
            
            // Substituir cada placeholder no HTML
            foreach ($placeholders as $placeholder => $value) {
                $html = str_replace($placeholder, $value, $html);
            }
        }

        // Gerar PDF
        $pdf = Pdf::loadHTML($html);
        $pdf->setPaper('A4', 'portrait');
        $pdf->setOptions([
            'dpi' => 150,
            'defaultFont' => 'sans-serif',
            'isRemoteEnabled' => false,
            'isHtml5ParserEnabled' => true
        ]);

        return $pdf;
    }
    
    private function buildFullAddress($licenciado): string
    {
        $endereco = $licenciado->endereco ?? '';
        $cidade = $licenciado->cidade ?? '';
        $estado = $licenciado->estado ?? '';
        $cep = $this->formatCEP($licenciado->cep ?? '');
        
        $parts = array_filter([$endereco, $cidade, $estado, $cep]);
        return implode(', ', $parts);
    }

    private function sendContractEmail(Contract $contract, string $signatureToken)
    {
        $signatureUrl = route('contracts.sign', $signatureToken);
        
        // Log tempor√°rio - implementar envio real depois
        logger("Contrato #{$contract->id} enviado para: {$contract->licenciado->email}");
        logger("URL de assinatura: {$signatureUrl}");
        
        // Aqui voc√™ implementaria o envio real do email
        // Mail::to($contract->licenciado->email)->send(new ContractEmail($contract, $signatureUrl));
    }

    private function formatCNPJ(string $cnpj): string
    {
        $cnpj = preg_replace('/\D/', '', $cnpj);
        if (strlen($cnpj) === 14) {
            return preg_replace('/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/', '$1.$2.$3/$4-$5', $cnpj);
        }
        return $cnpj;
    }

    private function formatCPF(string $cpf): string
    {
        $cpf = preg_replace('/\D/', '', $cpf);
        if (strlen($cpf) === 11) {
            return preg_replace('/(\d{3})(\d{3})(\d{3})(\d{2})/', '$1.$2.$3-$4', $cpf);
        }
        return $cpf;
    }

    private function formatCEP(string $cep): string
    {
        $cep = preg_replace('/\D/', '', $cep);
        if (strlen($cep) === 8) {
            return preg_replace('/(\d{5})(\d{3})/', '$1-$2', $cep);
        }
        return $cep;
    }

    private function formatPhone(string $phone): string
    {
        $phone = preg_replace('/\D/', '', $phone);
        if (strlen($phone) === 11) {
            return preg_replace('/(\d{2})(\d{5})(\d{4})/', '($1) $2-$3', $phone);
        } elseif (strlen($phone) === 10) {
            return preg_replace('/(\d{2})(\d{4})(\d{4})/', '($1) $2-$3', $phone);
        }
        return $phone;
    }

    public function downloadContract(Contract $contract)
    {
        $filePath = $contract->signed_contract_path ?? $contract->contract_pdf_path;
        
        if (!$filePath || !Storage::disk('private')->exists($filePath)) {
            return redirect()->back()->withErrors(['error' => 'Arquivo n√£o encontrado.']);
        }

        $fileName = $contract->signed_contract_path ? 'contrato_assinado.pdf' : 'contrato.pdf';
        
        return Storage::disk('private')->download($filePath, $fileName);
    }

    public function updateNotes(Request $request, Contract $contract)
    {
        $request->validate([
            'observacoes' => 'nullable|string|max:1000'
        ]);

        $contract->update([
            'observacoes' => $request->observacoes
        ]);

        // Log da a√ß√£o
        $contract->logAction(
            'observacoes_atualizadas',
            'Observa√ß√µes do contrato atualizadas',
            auth()->id(),
            ['observacoes_antigas' => $contract->getOriginal('observacoes')]
        );

        return redirect()->back()->with('success', 'Observa√ß√µes atualizadas com sucesso!');
    }

    public function sendContract(Request $request, Contract $contract)
    {
        // Verificar se o contrato est√° no status correto para envio
        if ($contract->status !== 'criado') {
            return redirect()->back()->withErrors(['error' => 'Contrato n√£o est√° no status correto para envio.']);
        }

        try {
            // Gerar o PDF do contrato
            $pdfPath = $this->generateContractPDF($contract);
            
            // Gerar token √∫nico para assinatura
            $contract->generateSignatureToken();
            
            // Atualizar status e dados do contrato
            $contract->update([
                'status' => 'contrato_enviado',
                'contract_pdf_path' => $pdfPath,
                'sent_at' => now(),
                'contract_sent_by' => auth()->id()
            ]);

            // Enviar email para o licenciado
            $this->sendContractByEmail($contract);

            // Log da a√ß√£o
            $contract->logAction(
                'contrato_enviado',
                'Contrato gerado e enviado por email para o licenciado',
                auth()->id(),
                [
                    'pdf_path' => $pdfPath,
                    'email_enviado' => $contract->licenciado->email,
                    'signature_token' => $contract->signature_token
                ]
            );

            return redirect()->back()->with('success', 'Contrato gerado e enviado por email com sucesso!');

        } catch (\Exception $e) {
            \Log::error('Erro ao enviar contrato: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            return redirect()->back()->withErrors(['error' => 'Erro ao enviar contrato: ' . $e->getMessage()]);
        }
    }

    private function generateContractPDF(Contract $contract)
    {
        // Preparar dados do contrato
        $contractData = $this->prepareContractData($contract);
        
        // Obter template padr√£o
        $template = ContractTemplate::getDefault();
        
        if (!$template) {
            throw new \Exception('Template de contrato n√£o encontrado.');
        }

        // Gerar PDF usando DomPDF
        $pdf = $this->generatePDF($template, $contractData);
        
        // Salvar PDF no storage privado
        $fileName = 'contract_' . $contract->id . '_' . time() . '.pdf';
        $filePath = 'contracts/' . $fileName;
        
        Storage::disk('private')->put($filePath, $pdf->output());
        
        return $filePath;
    }

    private function sendContractByEmail(Contract $contract)
    {
        $licenciado = $contract->licenciado;
        
        // URL para assinatura do contrato
        $signatureUrl = url('/contracts/sign/' . $contract->signature_token);
        
        // Dados para o email
        $emailData = [
            'licenciado' => $licenciado,
            'contract' => $contract,
            'signature_url' => $signatureUrl,
            'company_name' => config('app.name'),
        ];

        // Enviar email (usando Mail facade)
        try {
            \Mail::send('emails.contract-sent', $emailData, function ($message) use ($licenciado, $contract) {
                $message->to($licenciado->email, $licenciado->razao_social)
                        ->subject('Contrato para Assinatura Digital - ' . config('app.name'))
                        ->from(config('mail.from.address'), config('mail.from.name'));
                
                // Anexar PDF do contrato
                if ($contract->contract_pdf_path && Storage::disk('private')->exists($contract->contract_pdf_path)) {
                    $message->attachData(
                        Storage::disk('private')->get($contract->contract_pdf_path),
                        'contrato.pdf',
                        ['mime' => 'application/pdf']
                    );
                }
            });

            \Log::info('Email de contrato enviado com sucesso', [
                'contract_id' => $contract->id,
                'email' => $licenciado->email
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao enviar email do contrato: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'email' => $licenciado->email
            ]);
            
            throw new \Exception('Erro ao enviar email: ' . $e->getMessage());
        }
    }

    public function showSignaturePage($token)
    {
        // Buscar contrato pelo token
        $contract = Contract::where('signature_token', $token)->first();
        
        if (!$contract) {
            abort(404, 'Contrato n√£o encontrado ou token inv√°lido.');
        }

        // Verificar se o contrato est√° no status correto
        if (!in_array($contract->status, ['contrato_enviado', 'aguardando_assinatura'])) {
            return view('contracts.sign-error', [
                'message' => 'Este contrato n√£o est√° dispon√≠vel para assinatura.',
                'contract' => $contract
            ]);
        }

        // Atualizar status para "aguardando assinatura" se ainda n√£o estiver
        if ($contract->status === 'contrato_enviado') {
            $contract->update(['status' => 'aguardando_assinatura']);
        }

        // Preparar dados do contrato para exibi√ß√£o
        $contractData = $this->prepareContractData($contract);

        return view('contracts.sign', [
            'contract' => $contract,
            'licenciado' => $contract->licenciado,
            'contractData' => $contractData
        ]);
    }

    public function processSignature(Request $request, $token)
    {
        // Validar dados da assinatura
        $request->validate([
            'full_name' => 'required|string|max:255',
            'document' => 'required|string|max:20',
            'email' => 'required|email|max:255',
            'ip_address' => 'nullable|ip',
            'signature_date' => 'required|date',
            'accept_terms' => 'required|accepted'
        ]);

        // Buscar contrato pelo token
        $contract = Contract::where('signature_token', $token)->first();
        
        if (!$contract) {
            return response()->json(['error' => 'Contrato n√£o encontrado.'], 404);
        }

        // Verificar se o contrato est√° no status correto
        if ($contract->status !== 'aguardando_assinatura') {
            return response()->json(['error' => 'Contrato n√£o est√° dispon√≠vel para assinatura.'], 400);
        }

        try {
            // Dados da assinatura
            $signatureData = [
                'signer_name' => $request->full_name,
                'signer_document' => $request->document,
                'signer_email' => $request->email,
                'signed_at' => $request->signature_date,
                'ip_address' => $request->ip() ?? $request->ip_address,
                'user_agent' => $request->userAgent(),
                'signature_hash' => hash('sha256', $contract->id . $request->full_name . $request->document . now())
            ];

            // Atualizar contrato com dados da assinatura
            $contract->update([
                'status' => 'contrato_assinado',
                'signature_data' => json_encode($signatureData),
                'contract_signed_at' => now(),
                'signer_ip' => $signatureData['ip_address']
            ]);

            // Gerar PDF do contrato assinado
            $this->generateSignedContractPDF($contract, $signatureData);

            // Log da assinatura
            $contract->logAction(
                'contrato_assinado',
                'Contrato assinado digitalmente pelo licenciado',
                null, // Sem usu√°rio autenticado
                $signatureData
            );

            // Enviar email de confirma√ß√£o
            $this->sendSignatureConfirmationEmail($contract);
            
            // Aprovar automaticamente o licenciado
            $this->approveContractAndLicensee($contract);

            return response()->json([
                'success' => true,
                'message' => 'Contrato assinado com sucesso!',
                'redirect' => route('contracts.sign.success', ['token' => $token])
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao processar assinatura: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'token' => $token,
                'error' => $e->getTraceAsString()
            ]);

            return response()->json([
                'error' => 'Erro ao processar assinatura: ' . $e->getMessage()
            ], 500);
        }
    }

    private function generateSignedContractPDF(Contract $contract, array $signatureData)
    {
        // Preparar dados do contrato incluindo assinatura
        $contractData = $this->prepareContractData($contract);
        $contractData['signature'] = $signatureData;
        
        // Obter template padr√£o
        $template = ContractTemplate::getDefault();
        
        // Gerar PDF com dados de assinatura
        $pdf = $this->generatePDF($template, $contractData);
        
        // Salvar PDF assinado no storage privado
        $fileName = 'contract_signed_' . $contract->id . '_' . time() . '.pdf';
        $filePath = 'contracts/signed/' . $fileName;
        
        Storage::disk('private')->put($filePath, $pdf->output());
        
        // Atualizar caminho do contrato assinado
        $contract->update(['signed_contract_path' => $filePath]);
        
        return $filePath;
    }

    private function sendSignatureConfirmationEmail(Contract $contract)
    {
        $licenciado = $contract->licenciado;
        $signatureData = json_decode($contract->signature_data, true);
        
        // Dados para o email
        $emailData = [
            'licenciado' => $licenciado,
            'contract' => $contract,
            'signature_data' => $signatureData,
            'company_name' => config('app.name'),
        ];

        // Enviar email de confirma√ß√£o
        try {
            \Mail::send('emails.contract-signed', $emailData, function ($message) use ($licenciado, $contract) {
                $message->to($licenciado->email, $licenciado->razao_social)
                        ->subject('Contrato Assinado com Sucesso - ' . config('app.name'))
                        ->from(config('mail.from.address'), config('mail.from.name'));
                
                // Anexar PDF do contrato assinado
                if ($contract->signed_contract_path && Storage::disk('private')->exists($contract->signed_contract_path)) {
                    $message->attachData(
                        Storage::disk('private')->get($contract->signed_contract_path),
                        'contrato_assinado.pdf',
                        ['mime' => 'application/pdf']
                    );
                }
            });

            \Log::info('Email de confirma√ß√£o de assinatura enviado', [
                'contract_id' => $contract->id,
                'email' => $licenciado->email
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao enviar email de confirma√ß√£o: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'email' => $licenciado->email
            ]);
        }
    }

    public function showSignatureSuccess($token)
    {
        $contract = Contract::where('signature_token', $token)->first();
        
        if (!$contract || $contract->status !== 'contrato_assinado') {
            abort(404);
        }

        return view('contracts.sign-success', [
            'contract' => $contract,
            'licenciado' => $contract->licenciado
        ]);
    }
    
    private function approveContractAndLicensee(Contract $contract)
    {
        try {
            // Atualizar status do contrato para aprovado
            $contract->update([
                'status' => 'licenciado_aprovado',
                'licenciado_released_at' => now()
            ]);
            
            // Atualizar status do licenciado para ativo/aprovado
            $licenciado = $contract->licenciado;
            if ($licenciado) {
                $oldStatus = $licenciado->status;
                $licenciado->update([
                    'status' => 'ativo' // ou 'aprovado' dependendo da sua estrutura
                ]);
                
                // Log da aprova√ß√£o autom√°tica
                $contract->logAction(
                    'licenciado_aprovado_automaticamente',
                    'Licenciado aprovado automaticamente ap√≥s assinatura do contrato',
                    null, // Sistema autom√°tico
                    [
                        'status_anterior' => $oldStatus,
                        'status_novo' => 'ativo',
                        'aprovado_em' => now()->toISOString()
                    ]
                );
                
                // Enviar email de aprova√ß√£o para o licenciado
                $this->sendLicenseeApprovalEmail($contract);
                
                \Log::info('Licenciado aprovado automaticamente ap√≥s assinatura', [
                    'contract_id' => $contract->id,
                    'licenciado_id' => $licenciado->id,
                    'licenciado_email' => $licenciado->email,
                    'status_anterior' => $oldStatus,
                    'status_novo' => 'ativo'
                ]);
            }
            
        } catch (\Exception $e) {
            \Log::error('Erro ao aprovar licenciado automaticamente: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);
            
            // N√£o falhar o processo de assinatura por causa deste erro
            // apenas registrar para investiga√ß√£o posterior
        }
    }
    
    private function sendLicenseeApprovalEmail(Contract $contract)
    {
        $licenciado = $contract->licenciado;
        
        // Dados para o email de aprova√ß√£o
        $emailData = [
            'licenciado' => $licenciado,
            'contract' => $contract,
            'company_name' => config('app.name'),
            'approval_date' => now()
        ];

        try {
            \Mail::send('emails.licensee-approved', $emailData, function ($message) use ($licenciado, $contract) {
                $message->to($licenciado->email, $licenciado->razao_social)
                        ->subject('üéâ Parab√©ns! Seu licenciamento foi aprovado - ' . config('app.name'))
                        ->from(config('mail.from.address'), config('mail.from.name'));
            });

            \Log::info('Email de aprova√ß√£o de licenciado enviado', [
                'contract_id' => $contract->id,
                'email' => $licenciado->email
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao enviar email de aprova√ß√£o do licenciado: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'email' => $licenciado->email
            ]);
        }
    }

    // Endpoints para steps encadeados
    public function uploadTemplate(Request $request, Contract $contract)
    {
        $request->validate([
            'template' => 'required|file|mimes:blade.php,html,docx|max:5120', // 5MB max
        ]);

        try {
            if (!in_array($contract->status, ['draft', 'criado'])) {
                return response()->json(['error' => 'Contrato n√£o est√° no status correto para upload de template.'], 400);
            }

            $file = $request->file('template');
            $filename = 'template_' . $contract->id . '_' . time() . '.' . $file->getClientOriginalExtension();
            $path = $file->storeAs('contracts/templates', $filename);

            $contract->update([
                'status' => 'template_uploaded',
                'template_path' => $path,
                'meta' => json_encode(array_merge(
                    json_decode($contract->meta ?? '{}', true),
                    ['template_uploaded_at' => now()->toISOString()]
                ))
            ]);

            $contract->logAction(
                'template_uploaded',
                'Modelo de contrato enviado',
                auth()->id(),
                ['filename' => $filename, 'path' => $path]
            );

            return response()->json([
                'success' => true,
                'message' => 'Modelo de contrato enviado com sucesso!',
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao fazer upload do template: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            return response()->json(['error' => 'Erro ao fazer upload: ' . $e->getMessage()], 500);
        }
    }

    public function fillTemplate(Request $request, Contract $contract)
    {
        try {
            if ($contract->status !== 'template_uploaded') {
                return response()->json(['error' => 'Template deve ser enviado antes do preenchimento.'], 400);
            }

            if (!$contract->template_path) {
                return response()->json(['error' => 'Template n√£o encontrado.'], 400);
            }

            // Ler template
            $templateContent = \Storage::get($contract->template_path);
            
            // Preparar dados do licenciado
            $licenciado = $contract->licenciado;
            $placeholders = [
                '{{NOME}}' => $licenciado->razao_social ?? $licenciado->nome_fantasia ?? 'N/A',
                '{{DOCUMENTO}}' => $this->formatDocument($licenciado->cnpj_cpf ?? ''),
                '{{ENDERECO_COMPLETO}}' => $this->buildFullAddress($licenciado),
                '{{CEP}}' => $this->formatCEP($licenciado->cep ?? ''),
            ];

            // Substituir placeholders
            $filledContent = $templateContent;
            foreach ($placeholders as $placeholder => $value) {
                $filledContent = str_replace($placeholder, $value, $filledContent);
            }

            // Sanitizar HTML
            $sanitizedHtml = $this->sanitizeHtml($filledContent);

            // Salvar HTML preenchido
            $contract->update([
                'status' => 'filled',
                'meta' => json_encode(array_merge(
                    json_decode($contract->meta ?? '{}', true),
                    [
                        'filled_html' => $sanitizedHtml,
                        'filled_at' => now()->toISOString(),
                        'placeholders_used' => $placeholders
                    ]
                ))
            ]);

            $contract->logAction(
                'template_filled',
                'Modelo preenchido com dados do licenciado',
                auth()->id(),
                ['placeholders_count' => count($placeholders)]
            );

            return response()->json([
                'success' => true,
                'message' => 'Modelo preenchido com sucesso!',
                'preview_html' => $sanitizedHtml,
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao preencher template: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            $contract->update([
                'status' => 'error',
                'last_error' => $e->getMessage()
            ]);

            return response()->json(['error' => 'Erro ao preencher template: ' . $e->getMessage()], 500);
        }
    }


    public function sendEmail(Request $request, Contract $contract)
    {
        try {
            if ($contract->status !== 'pdf_ready') {
                return response()->json(['error' => 'PDF deve ser gerado antes do envio.'], 400);
            }

            // Gerar token de assinatura se n√£o existir
            if (!$contract->signature_token) {
                $contract->generateSignatureToken();
            }

            // Enviar email
            $this->sendContractByEmail($contract);

            $contract->update([
                'status' => 'sent',
                'sent_at' => now()
            ]);

            $contract->logAction(
                'email_sent',
                'Contrato enviado por email para assinatura',
                auth()->id(),
                [
                    'email_destinatario' => $contract->licenciado->email,
                    'signature_url' => route('contracts.sign.show', $contract->signature_token)
                ]
            );

            return response()->json([
                'success' => true,
                'message' => 'Contrato enviado por email!',
                'sent_to' => $contract->licenciado->email,
                'sent_at' => $contract->sent_at->format('d/m/Y H:i:s'),
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao enviar email: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            $contract->update([
                'status' => 'error',
                'last_error' => $e->getMessage()
            ]);

            return response()->json(['error' => 'Erro ao enviar email: ' . $e->getMessage()], 500);
        }
    }

    public function getSignatureStatus(Contract $contract)
    {
        try {
            $status = 'pending';
            
            if ($contract->status === 'signed') {
                $status = 'signed';
            } elseif ($contract->status === 'approved') {
                $status = 'approved';
            } elseif (in_array($contract->status, ['sent', 'aguardando_assinatura'])) {
                $status = 'pending';
            }

            return response()->json([
                'status' => $status,
                'contract_status' => $contract->status,
                'signed_at' => $contract->signed_at?->format('d/m/Y H:i:s'),
                'signature_data' => $contract->signature_data ? json_decode($contract->signature_data, true) : null,
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao verificar status de assinatura: ' . $e->getMessage(), [
                'contract_id' => $contract->id
            ]);

            return response()->json(['error' => 'Erro ao verificar status'], 500);
        }
    }

    public function approve(Request $request, Contract $contract)
    {
        try {
            if ($contract->status !== 'signed') {
                return response()->json(['error' => 'Contrato deve estar assinado para aprova√ß√£o.'], 400);
            }

            // Aprovar contrato
            $contract->update([
                'status' => 'approved',
                'approved_at' => now()
            ]);

            // Atualizar status do licenciado
            $licenciado = $contract->licenciado;
            if ($licenciado) {
                $licenciado->update(['status' => 'ativo']);
            }

            $contract->logAction(
                'contract_approved',
                'Contrato aprovado e licenciado liberado',
                auth()->id(),
                ['approved_at' => now()->toISOString()]
            );

            // Enviar email de aprova√ß√£o
            $this->sendApprovalEmail($contract);

            return response()->json([
                'success' => true,
                'message' => 'Contrato aprovado e licenciado liberado!',
                'approved_at' => $contract->approved_at->format('d/m/Y H:i:s'),
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao aprovar contrato: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            return response()->json(['error' => 'Erro ao aprovar contrato: ' . $e->getMessage()], 500);
        }
    }

    public function signatureWebhook(Request $request)
    {
        try {
            // Validar webhook (implementar conforme provedor de assinatura)
            $contractId = $request->input('contract_id');
            $status = $request->input('status');
            
            $contract = Contract::find($contractId);
            if (!$contract) {
                return response()->json(['error' => 'Contrato n√£o encontrado'], 404);
            }

            if ($status === 'signed') {
                $contract->update([
                    'status' => 'signed',
                    'signed_at' => now(),
                    'signature_data' => json_encode($request->input('signature_data', []))
                ]);

                $contract->logAction(
                    'webhook_signature_received',
                    'Assinatura recebida via webhook',
                    null,
                    $request->all()
                );
            }

            return response()->json(['success' => true]);

        } catch (\Exception $e) {
            \Log::error('Erro no webhook de assinatura: ' . $e->getMessage(), [
                'request' => $request->all(),
                'error' => $e->getTraceAsString()
            ]);

            return response()->json(['error' => 'Erro no webhook'], 500);
        }
    }

    // M√©todos auxiliares
    private function formatDocument(string $document): string
    {
        $clean = preg_replace('/[^0-9]/', '', $document);
        
        if (strlen($clean) === 11) {
            // CPF
            return preg_replace('/(\d{3})(\d{3})(\d{3})(\d{2})/', '$1.$2.$3-$4', $clean);
        } elseif (strlen($clean) === 14) {
            // CNPJ
            return preg_replace('/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/', '$1.$2.$3/$4-$5', $clean);
        }
        
        return $document;
    }



    private function sanitizeHtml(string $html): string
    {
        // Sanitizar HTML removendo scripts e tags perigosas
        $allowedTags = '<p><br><div><span><strong><em><ul><li><ol><h1><h2><h3><h4><h5><h6><table><tr><td><th><thead><tbody><img>';
        return strip_tags($html, $allowedTags);
    }

    private function sendApprovalEmail(Contract $contract)
    {
        try {
            // Implementar envio de email de aprova√ß√£o
            \Log::info('Email de aprova√ß√£o enviado', [
                'contract_id' => $contract->id,
                'licensee_email' => $contract->licenciado->email
            ]);
        } catch (\Exception $e) {
            \Log::error('Erro ao enviar email de aprova√ß√£o: ' . $e->getMessage());
        }
    }

    // Novos endpoints para steps encadeados
    public function uploadTemplate(Request $request, Contract $contract)
    {
        try {
            $request->validate([
                'template' => 'required|file|mimes:blade,html,docx|max:10240', // 10MB max
            ]);

            if ($contract->status !== 'criado') {
                return response()->json(['error' => 'Contrato n√£o est√° no status correto para upload de template.'], 400);
            }

            $file = $request->file('template');
            $filename = 'template_' . $contract->id . '_' . time() . '.' . $file->getClientOriginalExtension();
            $path = $file->storeAs('contracts/templates', $filename);

            $contract->update([
                'status' => 'template_uploaded',
                'template_path' => $path,
                'meta' => json_encode(array_merge(
                    json_decode($contract->meta ?? '{}', true),
                    ['template_original_name' => $file->getClientOriginalName()]
                ))
            ]);

            $contract->logAction(
                'template_uploaded',
                'Template de contrato carregado: ' . $file->getClientOriginalName(),
                auth()->id(),
                ['template_path' => $path, 'original_name' => $file->getClientOriginalName()]
            );

            return response()->json([
                'success' => true,
                'message' => 'Template carregado com sucesso!',
                'template_name' => $file->getClientOriginalName(),
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao fazer upload do template: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            $contract->update([
                'status' => 'error',
                'last_error' => $e->getMessage()
            ]);

            return response()->json(['error' => 'Erro ao fazer upload: ' . $e->getMessage()], 500);
        }
    }

    public function fillTemplate(Request $request, Contract $contract)
    {
        try {
            if ($contract->status !== 'template_uploaded') {
                return response()->json(['error' => 'Template deve ser carregado antes do preenchimento.'], 400);
            }

            if (!$contract->template_path || !Storage::exists($contract->template_path)) {
                return response()->json(['error' => 'Template n√£o encontrado.'], 400);
            }

            // Ler template
            $templateContent = Storage::get($contract->template_path);
            
            // Preparar dados do licenciado
            $licensee = $contract->licenciado;
            $placeholders = [
                '{{NOME}}' => $licensee->razao_social ?? $licensee->nome_fantasia ?? 'Nome n√£o informado',
                '{{DOCUMENTO}}' => $this->formatDocument($licensee->cnpj_cpf ?? ''),
                '{{ENDERECO_COMPLETO}}' => $this->buildFullAddress($licensee),
                '{{CEP}}' => $this->formatCEP($licensee->cep ?? ''),
            ];

            // Substituir placeholders
            $filledHtml = $templateContent;
            foreach ($placeholders as $placeholder => $value) {
                $filledHtml = str_replace($placeholder, $value, $filledHtml);
            }

            // Sanitizar HTML
            $filledHtml = $this->sanitizeHtml($filledHtml);

            // Salvar HTML preenchido
            $contract->update([
                'status' => 'filled',
                'meta' => json_encode(array_merge(
                    json_decode($contract->meta ?? '{}', true),
                    [
                        'filled_html' => $filledHtml,
                        'placeholders_used' => $placeholders,
                        'filled_at' => now()->toISOString()
                    ]
                ))
            ]);

            $contract->logAction(
                'template_filled',
                'Template preenchido com dados do licenciado',
                auth()->id(),
                ['placeholders_count' => count($placeholders)]
            );

            return response()->json([
                'success' => true,
                'message' => 'Template preenchido com sucesso!',
                'preview_html' => $this->generateSafePreview($filledHtml),
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao preencher template: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            $contract->update([
                'status' => 'error',
                'last_error' => $e->getMessage()
            ]);

            return response()->json(['error' => 'Erro ao preencher template: ' . $e->getMessage()], 500);
        }
    }

    public function generatePdfFromTemplate(Request $request, Contract $contract)
    {
        try {
            if ($contract->status !== 'filled') {
                return response()->json(['error' => 'Template deve ser preenchido antes da gera√ß√£o do PDF.'], 400);
            }

            $meta = json_decode($contract->meta ?? '{}', true);
            if (!isset($meta['filled_html'])) {
                return response()->json(['error' => 'HTML preenchido n√£o encontrado.'], 400);
            }

            // Gerar PDF usando DomPDF
            $pdf = Pdf::loadHTML($meta['filled_html']);
            $pdf->setPaper('A4', 'portrait');
            $pdf->setOptions([
                'dpi' => 150,
                'defaultFont' => 'sans-serif',
                'isRemoteEnabled' => false,
                'isHtml5ParserEnabled' => true
            ]);

            // Salvar PDF
            $pdfFilename = 'contract_' . $contract->id . '_' . time() . '.pdf';
            $pdfPath = 'contracts/pdf/' . $pdfFilename;
            Storage::put($pdfPath, $pdf->output());

            $contract->update([
                'status' => 'pdf_ready',
                'pdf_path' => $pdfPath,
                'meta' => json_encode(array_merge($meta, [
                    'pdf_generated_at' => now()->toISOString(),
                    'pdf_filename' => $pdfFilename
                ]))
            ]);

            $contract->logAction(
                'pdf_generated',
                'PDF do contrato gerado com sucesso',
                auth()->id(),
                ['pdf_path' => $pdfPath, 'pdf_size' => Storage::size($pdfPath)]
            );

            return response()->json([
                'success' => true,
                'message' => 'PDF gerado com sucesso!',
                'pdf_url' => route('contracts.download', $contract),
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao gerar PDF: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            $contract->update([
                'status' => 'error',
                'last_error' => $e->getMessage()
            ]);

            return response()->json(['error' => 'Erro ao gerar PDF: ' . $e->getMessage()], 500);
        }
    }

    public function sendContractEmail(Request $request, Contract $contract)
    {
        try {
            if ($contract->status !== 'pdf_ready') {
                return response()->json(['error' => 'PDF deve ser gerado antes do envio.'], 400);
            }

            if (!$contract->pdf_path || !Storage::exists($contract->pdf_path)) {
                return response()->json(['error' => 'PDF n√£o encontrado.'], 400);
            }

            // Gerar token de assinatura se n√£o existir
            if (!$contract->signature_token) {
                $contract->generateSignatureToken();
            }

            // Enviar email
            $this->sendContractByEmail($contract);

            $contract->update([
                'status' => 'sent',
                'sent_at' => now()
            ]);

            $contract->logAction(
                'email_sent',
                'Contrato enviado por email para assinatura',
                auth()->id(),
                [
                    'email_destinatario' => $contract->licenciado->email,
                    'signature_url' => route('contracts.sign.show', $contract->signature_token),
                    'sent_at' => now()->toISOString()
                ]
            );

            return response()->json([
                'success' => true,
                'message' => 'Contrato enviado por email com sucesso!',
                'sent_to' => $contract->licenciado->email,
                'sent_at' => $contract->sent_at->format('d/m/Y H:i:s'),
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao enviar email: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            $contract->update([
                'status' => 'error',
                'last_error' => $e->getMessage()
            ]);

            return response()->json(['error' => 'Erro ao enviar email: ' . $e->getMessage()], 500);
        }
    }

    public function checkSignatureStatus(Contract $contract)
    {
        try {
            $status = 'pending';
            $signatureData = null;

            if ($contract->status === 'signed') {
                $status = 'signed';
                $signatureData = json_decode($contract->signature_data ?? '{}', true);
            } elseif ($contract->status === 'error') {
                $status = 'error';
            }

            return response()->json([
                'status' => $status,
                'contract_status' => $contract->status,
                'signed_at' => $contract->signed_at?->format('d/m/Y H:i:s'),
                'signature_data' => $signatureData,
                'can_approve' => $contract->status === 'signed',
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao verificar status de assinatura: ' . $e->getMessage(), [
                'contract_id' => $contract->id
            ]);

            return response()->json(['error' => 'Erro ao verificar status'], 500);
        }
    }

    public function approveContract(Request $request, Contract $contract)
    {
        try {
            if ($contract->status !== 'signed') {
                return response()->json(['error' => 'Contrato deve estar assinado para aprova√ß√£o.'], 400);
            }

            // Aprovar contrato
            $contract->update([
                'status' => 'approved',
                'approved_at' => now()
            ]);

            // Atualizar status do licenciado
            $licensee = $contract->licenciado;
            if ($licensee) {
                $licensee->update(['status' => 'ativo']);
            }

            $contract->logAction(
                'contract_approved',
                'Contrato aprovado e licenciado liberado',
                auth()->id(),
                [
                    'approved_at' => now()->toISOString(),
                    'licensee_status_updated' => 'ativo'
                ]
            );

            // Enviar email de aprova√ß√£o (opcional)
            $this->sendApprovalEmail($contract);

            return response()->json([
                'success' => true,
                'message' => 'Contrato aprovado e licenciado liberado com sucesso!',
                'approved_at' => $contract->approved_at->format('d/m/Y H:i:s'),
                'licensee_url' => route('licenciados.show', $contract->licenciado),
                'contract' => $contract->fresh()
            ]);

        } catch (\Exception $e) {
            \Log::error('Erro ao aprovar contrato: ' . $e->getMessage(), [
                'contract_id' => $contract->id,
                'error' => $e->getTraceAsString()
            ]);

            return response()->json(['error' => 'Erro ao aprovar contrato: ' . $e->getMessage()], 500);
        }
    }

    public function signatureWebhook(Request $request)
    {
        try {
            // Validar webhook (implementar conforme provedor de assinatura)
            $contractId = $request->input('contract_id');
            $status = $request->input('status');
            $signatureData = $request->input('signature_data', []);

            $contract = Contract::find($contractId);
            if (!$contract) {
                return response()->json(['error' => 'Contrato n√£o encontrado'], 404);
            }

            if ($status === 'signed') {
                $contract->update([
                    'status' => 'signed',
                    'signed_at' => now(),
                    'signature_data' => json_encode($signatureData)
                ]);

                $contract->logAction(
                    'signature_received',
                    'Assinatura recebida via webhook',
                    null,
                    $signatureData
                );
            }

            return response()->json(['success' => true]);

        } catch (\Exception $e) {
            \Log::error('Erro no webhook de assinatura: ' . $e->getMessage(), [
                'request_data' => $request->all(),
                'error' => $e->getTraceAsString()
            ]);

            return response()->json(['error' => 'Erro interno'], 500);
        }
    }



    private function sanitizeHtml(string $html): string
    {
        // Remover scripts e outros elementos perigosos
        $html = preg_replace('/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/mi', '', $html);
        $html = preg_replace('/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/mi', '', $html);
        $html = preg_replace('/on\w+="[^"]*"/mi', '', $html);
        $html = preg_replace('/on\w+=\'[^\']*\'/mi', '', $html);
        
        return $html;
    }

    private function generateSafePreview(string $html): string
    {
        // Truncar HTML para preview
        $preview = strip_tags($html, '<p><br><div><span><strong><em><ul><li><h1><h2><h3><h4><h5><h6>');
        return substr($preview, 0, 1000) . (strlen($preview) > 1000 ? '...' : '');
    }

    private function sendApprovalEmail(Contract $contract)
    {
        // Implementar envio de email de aprova√ß√£o
        // Usar o template de email j√° criado anteriormente
        try {
            \Mail::send('emails.licensee-approved', [
                'licenciado' => $contract->licenciado,
                'contract' => $contract,
                'company_name' => config('app.name'),
                'approval_date' => now()
            ], function ($message) use ($contract) {
                $message->to($contract->licenciado->email, $contract->licenciado->razao_social)
                        ->subject('Parab√©ns! Seu contrato foi aprovado - ' . config('app.name'))
                        ->from(config('mail.from.address'), config('mail.from.name'));
            });
        } catch (\Exception $e) {
            \Log::error('Erro ao enviar email de aprova√ß√£o: ' . $e->getMessage());
        }
    }

}
